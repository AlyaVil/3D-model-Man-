/* 
Controls:
    - Drag left-click to rotate camera.
    - Drag middle-click to move camera.
    - Drag right-click to zoom.
    - E to toggle edges.
    - P to toggle points.
    - F to toggle faces. 
*/

Mesh mesh;

boolean showPoints = false;
boolean showEdges = true;
boolean showFaces = true;

PVector mouseClick = new PVector();

PVector rotStart = new PVector();
PVector posStart = new PVector();
PVector zoomStart = new PVector();

float rotx = 0;
float roty = 0;
float posx = 0;
float posy = 0;
float zoom = 0;


class Face {
  ArrayList<Integer> posIndexes;
  ArrayList<Integer> normalIndexes;
  
  Face(ArrayList<Integer> _posIndexes, ArrayList<Integer> _normalIndexes) {
    this.posIndexes = _posIndexes;
    this.normalIndexes = _normalIndexes;
  }
}


class Mesh {
  ArrayList<float[]> vertexes = new ArrayList<float[]>();
  ArrayList<float[]> vertexNormals = new ArrayList<float[]>();
  ArrayList<Face> faces = new ArrayList<Face>();
  PVector minPos = new PVector();
  PVector maxPos = new PVector();
  float offset = 0;
  
  void display() {
    pushMatrix();
    
    translate(width/2, height/2);
    translate(posx, posy, zoom);
    rotateY(radians(rotx));
    rotateX(radians(-roty));
    
    if (showEdges) {
      strokeWeight(1);
      stroke(200);
    } else {
      noStroke();
    }
if (showFaces) {
      fill(100);
    } else {
      noFill();
    }
    
    float centerOffsetx = -this.offset*(this.minPos.x+this.maxPos.x)/2;
    float centerOffsety = -this.offset*(this.minPos.y+this.maxPos.y)/2;
    float centerOffsetz = -this.offset*(this.minPos.z+this.maxPos.z)/2;
    
    for (int i = 0; i < this.faces.size(); i++) {
      Face face = this.faces.get(i);
      
      beginShape();
      for (int x = 0; x < face.posIndexes.size(); x++) {
        int normalIndex = face.normalIndexes.get(x);
        float[] n = this.vertexNormals.get(normalIndex);
        normal(n[0], n[1], n[2]);
        
        int vertIndex = face.posIndexes.get(x);
        float[] pos = this.vertexes.get(vertIndex);
        vertex(pos[0]*this.offset+centerOffsetx, pos[1]*this.offset+centerOffsety, pos[2]*this.offset+centerOffsetz);
      }
      endShape();
    }
    
    if (showPoints) {
      strokeWeight(3);
      stroke(255, 255, 0);
      for (int i = 0; i < this.vertexes.size()-1; i++) {
        float[] pos = this.vertexes.get(i);
        point(pos[0]*this.offset+centerOffsetx, pos[1]*this.offset+centerOffsety, pos[2]*this.offset+centerOffsetz);
      }
    }
    
    popMatrix();
  }
  
  // Only works in processing.js
  void read(String path, boolean mirrorX, boolean mirrorY, boolean mirrorZ) {
    String lines[] = loadStrings(path);
    
    for (int j = 0; j < lines.length; j++) {
      String line = lines[j];
      
      if (line.startsWith("v ")) { // Get vertex positions
        String[] lineSplit = split(line, " ");
        
        float x = float(lineSplit[1]);
        float y = float(lineSplit[2]);
        float z = float(lineSplit[3]);
